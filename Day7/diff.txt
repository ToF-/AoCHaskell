diff --git a/Day7/Specs.hs b/Day7/Specs.hs
index 98a72fb..7c9e146 100644
--- a/Day7/Specs.hs
+++ b/Day7/Specs.hs
@@ -1,9 +1,6 @@
 import Test.Hspec
 import Steps
 import Data.Map as M
-import Data.List as L
-import Data.Ord
-import Data.Maybe
 
 small = [(C,A) ,(C,F) ,(A,B) ,(A,D) ,(B,E) ,(D,E) ,(F,E)]
 
@@ -37,102 +34,23 @@ large=
 
 
 main = hspec $ do
-    describe "pred list" $ do
-        it "creates a list of all predecessors of all steps" $ do
-            (sort (M.toList (predList small))) `shouldBe` [(A,[C]),(B,[A]),(D,[A]),(E,[B,D,F]),(F,[C])]
-            (sort (M.toList (predList tiny))) `shouldBe` [(C,[Q]),(I,[Q]),(S,[I]),(Y,[C,I,Q,S])]
-
-    describe "succ list" $ do
-        it "creates a list of all successors of all steps" $ do
-            (sort (M.toList (succList small))) `shouldBe` [(A,[B,D]),(B,[E]),(C,[A,F]),(D,[E]),(F,[E])]
-            (sort (M.toList (succList tiny))) `shouldBe` [(C,[Y]),(I,[S,Y]),(Q,[C,I,Y]),(S,[Y])]
-
-    describe "start step" $ do
-        it "tells wich steps are starting steps from succ list" $ do
-            startSteps (succList small)  `shouldBe` [C]
-            startSteps (succList tiny)  `shouldBe` [Q]
-            startSteps (succList large)  `shouldBe` [B,E,U,V]
-
-    describe "steps" $ do
-        it "tells which steps to execute in which order" $ do
-            concatMap show (steps small)  `shouldBe` "CABDFE"
-            concatMap show (steps tiny)   `shouldBe` "QCISY"
-            concatMap show (steps large)   `shouldBe` "BETUFNVADWGPLRJOHMXKZQCISY"
-
-    describe "schedule" $ do
-        let scSmall = schedule 3 0 small
-            scTiny  = schedule 2 1000 tiny
-            scLarge = schedule 5 60 large
-            scSmallA = assignStep scSmall A 
-            scSmallF = assignStep scSmallA F
-            scSmallB = assignStep scSmallF B
-            scSmallD = assignStep scSmallB D
-            scTinyC = assignStep scTiny C 
-        it "has a number of todo list" $ do
-            jobs scSmall `shouldBe` [[],[],[]]
-
-        describe "critical path time" $ do
-            it "tells the minimum time to completion from a given step" $ do
-                (sort (M.toList (criticalPathTime scSmall)))
-                    `shouldBe` [(A,10),(B,7),(C,14),(D,9),(E,5),(F,11)]
-                (sort (M.toList (criticalPathTime scTiny))) 
-                    `shouldBe` [(C,2028),(I,3053),(Q,4070),(S,2044),(Y,1025)]
-      
-        describe "assign step" $ do
-            it "places a step with its duration in the todo list with the smallest total work" $ do
-                jobs scSmallA `shouldBe` [[Job A 1],[],[]]
-                jobs scTinyC  `shouldBe` [[Job C 1003],[]]
-                jobs scSmallF `shouldBe` [[Job A 1],[Job F 6],[]]
-                jobs scSmallB `shouldBe` [[Job A 1],[Job F 6],[Job B 2]]
-                jobs scSmallD `shouldBe` [[Job A 1,Job D 4],[Job F 6],[Job B 2]]
-
-        describe "idle until" $ do
-            describe "fills the todos with idle time until time of completion of a given step" $ do
-                    it "only if the step is being done"  $ do
-                        jobs (idleUntil A scSmall)  `shouldBe` [[],[],[]]
-                        jobs (idleUntil A scSmallD) `shouldBe` [[Job A 1,Job D 4],[Job F 6],[Job B 2]]
-                        jobs (idleUntil J scSmallF) `shouldBe` [[Job A 1],[Job F 6],[]]
-                    it "filling every other todo" $ do
-                        jobs (idleUntil A scSmallA)  `shouldBe` [[Job A 1],[Idle 1],[Idle 1]]
-                        jobs (idleUntil F scSmallD)  `shouldBe` [[Job A 1,Job D 4,Idle 1],[Job F 6],[Job B 2,Idle 4]]
-                    it "filling only the todo wih time smaller than time to completion of the step" $ do
-                        jobs (idleUntil D scSmallD)  `shouldBe` [[Job A 1,Job D 4],[Job F 6],[Job B 2,Idle 3]]
-
-        describe "start" $ do
-            it "sets the first next steps of a schedule to the starting steps" $ do 
-                nextSteps (start scSmall) `shouldBe` [C]
-                nextSteps (start scTiny)  `shouldBe` [Q]
-            it "ordered by descending critical path time" $ do
-                catMaybes (L.map (`M.lookup` criticalPathTime scLarge) [E,B,V,U]) `shouldBe` [527,468,332,331]
-                nextSteps (start scLarge)  `shouldBe` [E,B,V,U]
-            
-        describe "last step" $ do
-            it "tells the last step in the schedule" $ do
-                lastStep scSmall `shouldBe` E
-                lastStep scTiny  `shouldBe` Y
-                lastStep scLarge  `shouldBe` Y
-
-        describe "done" $ do
-            it "tells if the last step has been done in the schedule" $ do
-                done scSmall `shouldBe` False
-                let final = L.foldl assignStep scSmall [C,F,A,B,E,E]
-                done final `shouldBe` True
-
-        describe "smallest workload" $ do
-            it "tells the total time worked on the smallest todo" $ do
-                smallestWorkLoad scSmall `shouldBe` 0
-                smallestWorkLoad (next (start scSmall)) `shouldBe` 0
-        
-        describe "steps done" $ do
-            it "tells what steps are done at a given time" $ do
-                stepsDoneAt 0 scSmall  `shouldBe` []
-                stepsDoneAt 0 (next (start scSmall))  `shouldBe` []
-                stepsDoneAt 3 (next (start scSmall))  `shouldBe` [C]
-
-        describe "next" $ do
-            describe "assign the next step in a schedule" $ do
-                it "starting from the first starter step" $ do
-                    jobs (next (start scSmall)) `shouldBe` [[Job C 3],[],[]]
-                it "if a next step requires a step to be done, advance time with Idle" $ do
-                    nextSteps (next (start scSmall))  `shouldBe` [C]
-                    jobs (next (next (start scSmall))) `shouldBe` [[Job C 3,Job F 6],[Idle 3],[Idle 3]]
+    describe "a pred list" $ do
+        it "tells what are the predecessors of a step" $ do
+            let pl = predList small
+            E `M.lookup` pl `shouldBe` Just [B,D,F]
+            C `M.lookup` pl `shouldBe` Nothing
+
+    describe "a succ list" $ do
+        it "tells what are the successors of a step" $ do
+            let sl = succList small
+            C `M.lookup` sl `shouldBe` Just [A,F]
+            E `M.lookup` sl `shouldBe` Nothing
+            True `shouldBe` True 
+
+    describe "start steps" $ do
+        it "tells what are the starting steps of the list" $ do
+            startSteps (succList small) `shouldBe` [C]
+
+    describe "end step" $ do
+        it "tells what is the ending step of the list" $ do
+            endStep (succList small)  `shouldBe` E
diff --git a/Day7/Steps.hs b/Day7/Steps.hs
index 07d3868..b109894 100644
--- a/Day7/Steps.hs
+++ b/Day7/Steps.hs
@@ -2,178 +2,37 @@ module Steps
 where
 import Data.Map as M
 import Data.List as L
-import Data.Set as S
-import Data.Ord
-import Data.Maybe
 
-type Edge = (Step,Step)
-type StepList = Map Step [Step]
-type Time = Int
-type Index = Int
+data Step = A | B | C | D | E | F | G | H | I | J | K | L | M 
+          | N | O | P | Q | R | S | T | U | V | W | X | Y | Z 
+    deriving (Eq, Ord, Show, Enum)
 
-data Step = A|B|C|D|E|F|G|H|I|J|K|L|M|N|O|P|Q|R|S|T|U|V|W|X|Y|Z
-    deriving (Eq,Ord,Show,Enum)
+type Edge = (Step, Step)
+type PredList = Map Step [Step]
+type SuccList = Map Step [Step]
 
-data Job = Job Step Time | Idle Time
-    deriving (Eq,Show)
-           
-type CriticalTime = Map Step Time
-type Todo = [Job]
-data Schedule = Schedule { 
-    base :: Time,
-    todos :: [Todo],
-    successors :: StepList,
-    predecessors :: StepList,
-    criticalPathTime :: CriticalTime,
-    nextSteps :: [Step]
-} deriving (Eq, Show)
-
-predList :: [Edge] -> StepList 
-predList = L.foldl addPreds M.empty 
-
-succList :: [Edge] -> StepList 
-succList = L.foldl addSuccs M.empty
-
-addPreds :: StepList -> Edge -> StepList
-addPreds l (a,b) = insertWith add b [a] l
-
-addSuccs :: StepList -> Edge -> StepList
-addSuccs l (a,b) = insertWith add a [b] l
-
-add :: [Step] -> [Step] -> [Step]
-add ns n = nub (sort (n++ns))
-
-startSteps :: StepList -> [Step]
-startSteps m = sort (L.filter (\n -> not (n `elem` succs)) steps)
-    where
-    succs = L.concat (M.elems m)
-    steps = M.keys m
-
-steps :: [Edge] -> [Step]
-steps es = fst (visit ([],startSteps succs))
+predList :: [Edge] -> PredList
+predList = L.foldl addEdge M.empty
     where
-    succs = succList es
-    preds = predList es
-    visit (vs,[]) = (vs,[])
-    visit (vs,(n:ns)) = case fmap (L.filter allPredVisited) (M.lookup n succs) of
-        Just [] -> visit (vs',ns) 
-        Just ss -> visit (vs',sort (ss ++ ns)) 
-        Nothing -> visit (vs',ns)
-        where 
-        vs' = vs ++ [n]
-        allPredVisited n = case fmap (all (`elem` vs')) (M.lookup n preds) of
-            Nothing -> True
-            Just b -> b
+    addEdge :: PredList -> Edge -> PredList
+    addEdge pl (pred,succ) = M.insertWith (\l' l -> (L.nub . L.sort) (l ++ l')) succ [pred] pl
 
-makeCriticalPaths :: Time -> StepList -> Map Step Time
-makeCriticalPaths base preds = addCriticalPath 0 M.empty target
+succList :: [Edge] -> SuccList
+succList = L.foldl addEdge M.empty
     where
-    target = head (L.filter (\n -> not(n `elem` allPreds)) steps)
-    allPreds = L.concat (M.elems preds)
-    steps = M.keys preds
-
-    addCriticalPath :: Time -> Map Step Time -> Step -> Map Step Time
-    addCriticalPath t m n = case M.lookup n preds of
-        Nothing -> m'
-        Just ps -> L.foldl' (addCriticalPath t') m' ps
-        where
-        t' = t + base + 1 + fromEnum n
-        m' = M.insert n t' m
+    addEdge :: SuccList -> Edge -> SuccList
+    addEdge pl (pred,succ) = M.insertWith (\l' l -> (L.nub . L.sort) (l ++ l')) pred [succ] pl
 
-schedule ::  Int -> Time -> [Edge] -> Schedule
-schedule n b es = Schedule 
-    b 
-    (replicate n []) 
-    (succList es)
-    preds
-    (makeCriticalPaths b preds)
-    []
+startSteps :: SuccList -> [Step]
+startSteps sl = L.filter (not.(`elem` successors)) steps
     where
-    preds = predList es
+    steps = M.keys sl
+    successors = concat (M.elems sl)
 
-assignStep :: Schedule -> Step -> Schedule
-assignStep sc s = sc { todos = replace i t' ts }
+endStep :: SuccList -> Step
+endStep sl = case L.filter (not.(`elem` steps)) successors of
+    [] -> error "this SuccList has no ending step"
+    l -> head l
     where
-    ts = todos sc
-    i = snd (minimum (zip (L.map workLoad ts) [0..]))
-    t' = Job s (stepTime s) : ts !! i
-    
-    replace i a as = (L.take i as) ++ [a] ++ (L.drop (succ i) as)
-
-    stepTime s = fromEnum s + 1 + base sc
-
-workLoad :: [Job] -> Time
-workLoad = sum . L.map time
-
-time :: Job -> Time 
-time (Job _ t) = t
-time (Idle t)  = t
-    
-idleUntil :: Step -> Schedule -> Schedule
-idleUntil s sc = case findJob s (todos sc) of
-   Nothing -> sc
-   Just time -> sc { todos = fill time (todos sc) }
-
-findJob :: Step -> [Todo] -> Maybe Time
-findJob s [] = Nothing
-findJob s (((Job s' t):js):ts) = if s' == s then Just (t + workLoad js) else findJob s ts
-findJob s (((Idle _):_):ts) = findJob s ts
-findJob s ([]:ts) = findJob s ts
-
-fill :: Time -> [Todo] -> [Todo]
-fill tt = L.map (\j -> if workLoad j < tt then (Idle (tt - workLoad j) : j) else j)
-         
-start :: Schedule -> Schedule
-start sc = sc { nextSteps = firstSteps }
-    where
-    firstSteps :: [Step]
-    firstSteps = sortBy (descendingCriticalPathTime sc) (startSteps (successors sc))
-
-descendingCriticalPathTime :: Schedule -> Step -> Step -> Ordering
-descendingCriticalPathTime sc = flip (comparing (`M.lookup` (criticalPathTime sc)))
-
-jobs = L.map reverse . todos
-
-lastStep :: Schedule -> Step
-lastStep sc = head (L.filter ((Nothing==).(`M.lookup` succs)) (concat (M.elems succs)))
-    where succs = successors sc
-
-done :: Schedule -> Bool
-done sc = case findJob (lastStep sc) (todos sc) of
-    Nothing -> False
-    Just _ -> True
-
-next :: Schedule -> Schedule
-next sc = case (nextSteps sc) of 
-    (s:ss) -> assignStep (sc { nextSteps = ss}) s
-    [] -> case done sc of
-        True -> sc 
-        False -> assignNextStep sc
-
-stepsDoneAt :: Time -> Schedule -> [Step]
-stepsDoneAt t sc = L.concatMap (stepsDoneAtFor t) (todos sc)
-    where
-    stepsDoneAtFor t todo | workLoad todo <= t = catMaybes (L.map step todo)
-                          | otherwise         = []
-
-step :: Job -> Maybe Step
-step (Job s _) = Just s
-step _ = Nothing
-
-smallestWorkLoad :: Schedule -> Time
-smallestWorkLoad sc = minimum ((L.map workLoad) (todos sc))
-
-assignNextStep :: Schedule -> Schedule
-assignNextStep sc = sc { nextSteps = nextSteps' }
-    where
-    t = smallestWorkLoad sc
-    stepsDone = stepsDoneAt t sc
-    succsWithPredsDone sc = L.foldl addStepIfPrecIsDone [] stepsDone
-    nextSteps' = case succsWithPredsDone sc of
-        [] -> nextSteps $ assignNextStep ((L.foldl (\sch s -> idleUntil s sch) sc stepsDone))
-        ss -> ss
-
-    addStepIfPrecIsDone :: [Step] -> Step -> [Step]
-    addStepIfPrecIsDone acc s = case fmap (L.filter (`elem` stepsDone)) (M.lookup s (successors sc)) of
-        Nothing -> acc
-        Just ss -> acc ++ ss
+    steps = M.keys sl
+    successors = concat (M.elems sl)
